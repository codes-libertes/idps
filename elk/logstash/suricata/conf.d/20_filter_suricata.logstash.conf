
filter {
  if [fields][event][type] == "suricata" {
    # Initial handling of raw  message.
      mutate {
        add_field => {
          "[@metadata][resolve_ip2host]" => "false"
          "[@metadata][geoip_lookup]" => "true"
          "[@metadata][asn_lookup]" => "true"
          "[@metadata][cleanup_sigs]" => "false"
        }
        rename => {
          "[fields][event][type]" => "[event][type]"
          "[host]" => "[event][host]"
        }
        remove_field => [ "prospector", "source" ]
        remove_tag => [ "beats_input_codec_plain_applied" ]
        replace => {
          "@version" => "5.0.0"
        }
      }

      if [@metadata][ip_address] {
        mutate {
          add_field => { "[node][ipaddr]" => "%{[@metadata][ip_address]}" }
        }
      }
      if [beat][hostname] {
        mutate {
          rename => { "[beat][hostname]" => "[node][hostname]" }
        }
      }

      mutate {
        remove_field => [ "beat", "fields", "offset" ]
      }

    # Parse JSON
      json {
        skip_on_invalid_json => true
        source => "message"
      }

    # Process parsed JSON data.
      if "_jsonparsefailure" not in [tags] {
        # Cleanup unneeded fields.
          mutate {
            remove_field => [ "type", "message" ]
          }

        # Set @timestamp
          if [timestamp] {
            # 2018-05-28T22:54:43.665709+0000
            date {
              match => [ "[timestamp]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
              remove_field => [ "[timestamp]" ]
            }
          }
        
        # Set event.subtype
          if [event_type] {
            mutate {
              rename => { "[event_type]" => "[event][subtype]" }
            }
          }

        # Handle event-specific fields.
        if [event][subtype] != "stats" {
          # Convert date fields if present.
            if [flow][end] {
              date {
                match => [ "[flow][end]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
                target => [ "[flow][end]" ]
              }
            }
            if [flow][start] {
              date {
                match => [ "[flow][start]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
                target => [ "[flow][start]" ]
              }
            }
            if [tls][notafter] {
              date {
                match => [ "[tls][notafter]", "YYYY-MM-dd'T'HH:mm:ssZ" ]
                target => [ "[tls][notafter]" ]
              }
            }
            if [tls][notbefore] {
              date {
                match => [ "[tls][notbefore]", "YYYY-MM-dd'T'HH:mm:ssZ" ]
                target => [ "[tls][notbefore]" ]
              }
            }

          # Determine IP Version with CIDR checks.
            if [src_ip] {
              cidr {
                id => "suricata_ipv4_cidr_src"
                address => [ "%{[src_ip]}" ]
                network => [ "0.0.0.0/0" ]
                add_field => {
                  "[ip_version]" => "IPv4"
                }
              }
              if ![ip_version] {
                cidr {
                  id => "suricata_ipv6_cidr_src"
                  address => [ "%{[src_ip]}" ]
                  network => [ "::/0" ]
                  add_field => {
                    "[ip_version]" => "IPv6"
                  }
                }
              }
            } else if [dest_ip] {
              cidr {
                id => "suricata_ipv4_cidr_dest"
                address => [ "%{[dest_ip]}" ]
                network => [ "0.0.0.0/0" ]
                add_field => {
                  "[ip_version]" => "IPv4"
                }
              }
              if ![ip_version] {
                cidr {
                  id => "suricata_ipv6_cidr_dest"
                  address => [ "%{[dest_ip]}" ]
                  network => [ "::/0" ]
                  add_field => {
                    "[ip_version]" => "IPv6"
                  }
                }
              }
            }
            
          # If enabled, resolve names of source and destination IP addresses.
            if [dest_ip] {
              # If localhost then use the IP from the host field.
              if [dest_ip] == "127.0.0.1" {
                mutate {
                  id => "suricata_dest_hostname_localhost"
                  replace => { "[dest_hostname]" => "%{[event][host]}" }
                }
              } else {
                mutate {
                  id => "suricata_dest_hostname_ip"
                  add_field => { "[dest_hostname]" => "%{[dest_ip]}"}
                }
              }
              # Resolve destination IP address to hostname.
              if [@metadata][resolve_ip2host] == "true" {
                dns {
                  id => "suricata_dns_dest_hostname"
                  reverse => [ "[dest_hostname]" ]
                  action => "replace"
                  nameserver => "127.0.0.1"
                  hit_cache_size => "25000"
                  hit_cache_ttl => "900"
                  failed_cache_size => "75000"
                  failed_cache_ttl => "3600"
                }
              }
            }

            if [src_ip] {
              # If localhost then use the IP from the host field.
              if [src_ip] == "127.0.0.1" {
                mutate {
                  id => "suricata_src_hostname_localhost"
                  replace => { "[src_hostname]" => "%{[event][host]}" }
                }
              } else {
                mutate {
                  id => "suricata_src_hostname_ip"
                  add_field => { "[src_hostname]" => "%{[src_ip]}"}
                }
              }
              # Resolve source IP address to hostname.
              if [@metadata][resolve_ip2host] == "true" {
                dns {
                  id => "suricata_dns_src_hostname"
                  reverse => [ "[src_hostname]" ]
                  action => "replace"
                  nameserver => "127.0.0.1"
                  hit_cache_size => "25000"
                  hit_cache_ttl => "900"
                  failed_cache_size => "75000"
                  failed_cache_ttl => "3600"
                }
              }
            }
        }
      }
  }
}
